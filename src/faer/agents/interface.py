"""Agent interface contracts and data models.

This module defines the protocol and data structures that form the
contract between simulation output and the agent layer. All agents
must implement the ClinicalAgent protocol and produce ClinicalInsight
objects.

Design Principles:
- Pure functions: Agents are stateless transformers f(metrics) → insights
- Contract-first: Strict interfaces enable implementation swapping
- Fail-safe: Agent failures never crash simulation
- Testable: Deterministic inputs produce deterministic outputs
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Protocol, Optional, runtime_checkable


class Severity(Enum):
    """Insight severity levels aligned with clinical escalation protocols.

    Severity levels map to hospital escalation procedures:
    - CRITICAL: Immediate action required (red alert)
    - HIGH: Urgent attention needed (orange alert)
    - MEDIUM: Monitor closely (yellow alert)
    - LOW: Awareness item (green alert)
    - INFO: Informational only (blue, no action)
    """

    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


class InsightCategory(Enum):
    """Clinical insight categories for filtering and routing.

    Categories help users filter insights by domain and route
    them to appropriate clinical teams.
    """

    WAIT_TIME = "wait_time"
    CAPACITY = "capacity"
    PATIENT_SAFETY = "patient_safety"
    FLOW_BOTTLENECK = "flow_bottleneck"
    RESOURCE_UTILIZATION = "resource_utilization"
    BOARDING = "boarding"
    DOWNSTREAM = "downstream"
    AEROMEDICAL = "aeromedical"
    HANDOVER = "handover"
    COMPOUND_RISK = "compound_risk"


@dataclass(frozen=True)
class ClinicalInsight:
    """Immutable clinical insight generated by an agent.

    Attributes:
        severity: Alert level (CRITICAL, HIGH, MEDIUM, LOW, INFO)
        category: Clinical domain category
        title: Short headline, max 80 characters
        message: Detailed explanation with clinical context
        impact_metric: Primary metric affected by this issue
        evidence: Dict of metric names to values supporting this insight
        recommendation: Optional actionable guidance
        source_agent: Name of agent that generated this insight

    Example:
        ClinicalInsight(
            severity=Severity.CRITICAL,
            category=InsightCategory.WAIT_TIME,
            title="4-Hour Standard Breach",
            message="P95 treatment wait of 280 minutes exceeds NHS standard...",
            impact_metric="p95_treatment_wait",
            evidence={"p95_treatment_wait": 280.0, "threshold": 240.0},
            recommendation="Immediate capacity review required.",
            source_agent="heuristic_shadow",
        )
    """

    severity: Severity
    category: InsightCategory
    title: str
    message: str
    impact_metric: str
    evidence: dict[str, float]
    recommendation: Optional[str] = None
    source_agent: str = ""

    def __post_init__(self):
        if len(self.title) > 80:
            raise ValueError(f"Title must be ≤80 characters, got {len(self.title)}")


@dataclass(frozen=True)
class CapacityRecommendation:
    """Capacity intervention recommendation.

    Provides actionable guidance for capacity changes with
    expected impact estimates.

    Attributes:
        resource: Resource to modify (e.g., "ed_bays", "itu_beds")
        action: Type of change ("increase", "decrease", "rebalance")
        magnitude: Suggested change amount
        rationale: Why this recommendation
        expected_impact: Estimated metric improvements
        confidence: Estimate confidence ("high", "medium", "low")
        cost_indicator: Relative cost ("low", "medium", "high")
    """

    resource: str
    action: str
    magnitude: int
    rationale: str
    expected_impact: dict[str, float]
    confidence: str
    cost_indicator: str


@dataclass
class MetricsSummary:
    """Standardized metrics container for agent consumption.

    This is the primary interface between simulation output and agents.
    Agents should ONLY depend on this contract, never on internal
    ResultsCollector implementation details.

    The factory method `from_run_results()` handles conversion from
    raw simulation output to this standardized format.

    Attributes:
        scenario_name: Human-readable scenario identifier
        run_timestamp: ISO timestamp of when simulation was run
        n_replications: Number of replications in this run
        arrivals: Total patient arrivals
        arrivals_by_priority: Dict mapping priority (P1-P4) to count
        arrivals_by_mode: Dict mapping mode (ambulance, etc.) to count
        mean_triage_wait: Mean triage waiting time (minutes)
        mean_treatment_wait: Mean treatment waiting time (minutes)
        p95_treatment_wait: 95th percentile treatment wait (minutes)
        mean_system_time: Mean total time in system (minutes)
        p95_system_time: 95th percentile system time (minutes)
        p_delay: Proportion of patients who waited for treatment
        util_triage: Triage utilization (0-1 scale)
        util_ed_bays: ED bay utilization (0-1 scale)
        util_itu: ITU utilization (0-1 scale)
        util_ward: Ward utilization (0-1 scale)
        util_theatre: Theatre utilization (0-1 scale)
        itu_admissions: Count of ITU admissions
        mean_itu_wait: Mean wait for ITU bed (minutes)
        ward_admissions: Count of ward admissions
        mean_ward_wait: Mean wait for ward bed (minutes)
        theatre_admissions: Count of theatre admissions
        mean_theatre_wait: Mean wait for theatre (minutes)
        mean_boarding_time: Mean time boarding in ED (minutes)
        p_boarding: Proportion of patients who boarded
        mean_handover_delay: Mean ambulance handover delay (minutes)
        max_handover_delay: Maximum handover delay (minutes)
        aeromed_total: Total aeromedical evacuations
        aeromed_slots_missed: Count of missed aeromed slots
        mean_aeromed_slot_wait: Mean wait for aeromed slot (minutes)
        ci_bounds: Optional confidence intervals for metrics
        raw_metrics: Full raw metrics dict for advanced agents
    """

    # Core identifiers
    scenario_name: str
    run_timestamp: str
    n_replications: int

    # Demand metrics
    arrivals: float
    arrivals_by_priority: dict[str, float]
    arrivals_by_mode: dict[str, float]

    # Wait time metrics (minutes)
    mean_triage_wait: float
    mean_treatment_wait: float
    p95_treatment_wait: float
    mean_system_time: float
    p95_system_time: float
    p_delay: float

    # Utilization metrics (0-1 scale)
    util_triage: float
    util_ed_bays: float
    util_itu: float
    util_ward: float
    util_theatre: float

    # Downstream metrics
    itu_admissions: float
    mean_itu_wait: float
    ward_admissions: float
    mean_ward_wait: float
    theatre_admissions: float
    mean_theatre_wait: float

    # Boarding/blocking metrics
    mean_boarding_time: float
    p_boarding: float

    # Handover metrics
    mean_handover_delay: float
    max_handover_delay: float

    # Aeromedical metrics (optional)
    aeromed_total: float = 0.0
    aeromed_slots_missed: float = 0.0
    mean_aeromed_slot_wait: float = 0.0

    # Confidence intervals (optional, for display)
    ci_bounds: dict[str, tuple[float, float]] = field(default_factory=dict)

    # Raw data access (for advanced agents)
    raw_metrics: dict = field(default_factory=dict)

    @classmethod
    def from_run_results(
        cls,
        results: dict,
        scenario_name: str = "Unnamed",
    ) -> "MetricsSummary":
        """Factory method to create MetricsSummary from simulation output.

        Handles conversion from raw simulation results dict (which contains
        lists of values from multiple replications) to aggregated metrics.

        Args:
            results: Dict with metric names as keys and lists of values
            scenario_name: Human-readable name for this scenario

        Returns:
            MetricsSummary instance with aggregated metrics
        """

        def mean_of(key: str, default: float = 0.0) -> float:
            """Extract mean from list of replication values."""
            values = results.get(key, [default])
            if not values:
                return default
            return sum(values) / len(values)

        return cls(
            scenario_name=scenario_name,
            run_timestamp=datetime.now().isoformat(),
            n_replications=len(results.get("arrivals", [1])),
            # Demand
            arrivals=mean_of("arrivals"),
            arrivals_by_priority={
                "P1": mean_of("arrivals_P1"),
                "P2": mean_of("arrivals_P2"),
                "P3": mean_of("arrivals_P3"),
                "P4": mean_of("arrivals_P4"),
            },
            arrivals_by_mode={
                "ambulance": mean_of("arrivals_ambulance", 0),
                "helicopter": mean_of("arrivals_helicopter", 0),
                "walk_in": mean_of("arrivals_walkin", 0),
            },
            # Wait times
            mean_triage_wait=mean_of("mean_triage_wait"),
            mean_treatment_wait=mean_of("mean_treatment_wait"),
            p95_treatment_wait=mean_of("p95_treatment_wait"),
            mean_system_time=mean_of("mean_system_time"),
            p95_system_time=mean_of("p95_system_time"),
            p_delay=mean_of("p_delay"),
            # Utilization
            util_triage=mean_of("util_triage"),
            util_ed_bays=mean_of("util_ed_bays"),
            util_itu=mean_of("util_itu", 0),
            util_ward=mean_of("util_ward", 0),
            util_theatre=mean_of("util_theatre", 0),
            # Downstream
            itu_admissions=mean_of("itu_admissions", 0),
            mean_itu_wait=mean_of("mean_itu_wait", 0),
            ward_admissions=mean_of("ward_admissions", 0),
            mean_ward_wait=mean_of("mean_ward_wait", 0),
            theatre_admissions=mean_of("theatre_admissions", 0),
            mean_theatre_wait=mean_of("mean_theatre_wait", 0),
            # Boarding
            mean_boarding_time=mean_of("mean_boarding_time", 0),
            p_boarding=mean_of("p_boarding", 0),
            # Handover
            mean_handover_delay=mean_of("mean_handover_delay", 0),
            max_handover_delay=mean_of("max_handover_delay", 0),
            # Aeromedical
            aeromed_total=mean_of("aeromed_total", 0),
            aeromed_slots_missed=mean_of("aeromed_slots_missed", 0),
            mean_aeromed_slot_wait=mean_of("mean_aeromed_slot_wait", 0),
            # Raw
            raw_metrics=results,
        )


@runtime_checkable
class ClinicalAgent(Protocol):
    """Protocol defining the agent interface contract.

    All agents must implement this interface. This enables:
    - Dependency injection for testing
    - Runtime agent swapping (heuristic → LLM)
    - Future microservice decomposition

    Implementing classes must provide:
    - name: Unique identifier string
    - description: Human-readable purpose
    - analyze(): Core method transforming metrics to insights
    - health_check(): Verify agent is operational
    """

    @property
    def name(self) -> str:
        """Unique agent identifier."""
        ...

    @property
    def description(self) -> str:
        """Human-readable agent purpose."""
        ...

    def analyze(self, metrics: MetricsSummary) -> list[ClinicalInsight]:
        """Core analysis method: metrics → insights.

        Args:
            metrics: Standardized simulation output summary

        Returns:
            List of clinical insights (may be empty)

        Raises:
            AgentExecutionError: If analysis fails unrecoverably
        """
        ...

    def health_check(self) -> bool:
        """Verify agent is operational.

        For heuristic agents, always returns True.
        For LLM agents, verifies API key and connectivity.
        """
        ...


@dataclass
class AgentResult:
    """Container for agent execution result with metadata.

    Captures both the insights produced and execution metadata
    for observability and debugging.

    Attributes:
        agent_name: Name of the agent that produced this result
        execution_time_ms: Time taken to execute (milliseconds)
        insights: List of insights produced
        success: Whether execution completed successfully
        error_message: Error details if success is False
    """

    agent_name: str
    execution_time_ms: float
    insights: list[ClinicalInsight]
    success: bool
    error_message: Optional[str] = None


class AgentExecutionError(Exception):
    """Raised when an agent fails to execute.

    This exception should be caught by the orchestrator for
    fail-open behavior. It should include enough context to
    diagnose the failure.
    """

    pass
