"""Agent interface contracts and data models.

This module defines the protocol and data structures that form the
contract between simulation output and the agent layer. All agents
must implement the ClinicalAgent protocol and produce ClinicalInsight
objects.

Design Principles:
- Pure functions: Agents are stateless transformers f(metrics) → insights
- Contract-first: Strict interfaces enable implementation swapping
- Fail-safe: Agent failures never crash simulation
- Testable: Deterministic inputs produce deterministic outputs
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Protocol, Optional, runtime_checkable


class Severity(Enum):
    """Insight severity levels aligned with clinical escalation protocols.

    Severity levels map to hospital escalation procedures:
    - CRITICAL: Immediate action required (red alert)
    - HIGH: Urgent attention needed (orange alert)
    - MEDIUM: Monitor closely (yellow alert)
    - LOW: Awareness item (green alert)
    - INFO: Informational only (blue, no action)
    """

    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


class InsightCategory(Enum):
    """Clinical insight categories for filtering and routing.

    Categories help users filter insights by domain and route
    them to appropriate clinical teams.
    """

    WAIT_TIME = "wait_time"
    CAPACITY = "capacity"
    PATIENT_SAFETY = "patient_safety"
    FLOW_BOTTLENECK = "flow_bottleneck"
    RESOURCE_UTILIZATION = "resource_utilization"
    BOARDING = "boarding"
    DOWNSTREAM = "downstream"
    AEROMEDICAL = "aeromedical"
    HANDOVER = "handover"
    COMPOUND_RISK = "compound_risk"


@dataclass(frozen=True)
class ClinicalInsight:
    """Immutable clinical insight generated by an agent.

    Attributes:
        severity: Alert level (CRITICAL, HIGH, MEDIUM, LOW, INFO)
        category: Clinical domain category
        title: Short headline, max 80 characters
        message: Detailed explanation with clinical context
        impact_metric: Primary metric affected by this issue
        evidence: Dict of metric names to values supporting this insight
        recommendation: Optional actionable guidance
        source_agent: Name of agent that generated this insight
        confidence_level: Statistical confidence ("high", "medium", "low")
        ci_lower: Lower bound of metric's confidence interval
        ci_upper: Upper bound of metric's confidence interval
        threshold_overlap: True if CI spans the threshold boundary
        uncertainty_note: Additional context when confidence is low

    Example:
        ClinicalInsight(
            severity=Severity.CRITICAL,
            category=InsightCategory.WAIT_TIME,
            title="4-Hour Standard Breach",
            message="P95 treatment wait of 280 minutes exceeds NHS standard...",
            impact_metric="p95_treatment_wait",
            evidence={"p95_treatment_wait": 280.0, "threshold": 240.0},
            recommendation="Immediate capacity review required.",
            source_agent="heuristic_shadow",
            confidence_level="high",
            ci_lower=265.0,
            ci_upper=295.0,
        )
    """

    severity: Severity
    category: InsightCategory
    title: str
    message: str
    impact_metric: str
    evidence: dict[str, float]
    recommendation: Optional[str] = None
    source_agent: str = ""
    # Uncertainty-aware fields (defaults for backward compatibility)
    confidence_level: str = "high"  # "high", "medium", "low"
    ci_lower: Optional[float] = None
    ci_upper: Optional[float] = None
    threshold_overlap: bool = False
    uncertainty_note: str = ""

    def __post_init__(self):
        if len(self.title) > 80:
            raise ValueError(f"Title must be ≤80 characters, got {len(self.title)}")


@dataclass(frozen=True)
class CapacityRecommendation:
    """Capacity intervention recommendation.

    Provides actionable guidance for capacity changes with
    expected impact estimates.

    Attributes:
        resource: Resource to modify (e.g., "ed_bays", "itu_beds")
        action: Type of change ("increase", "decrease", "rebalance")
        magnitude: Suggested change amount
        rationale: Why this recommendation
        expected_impact: Estimated metric improvements
        confidence: Estimate confidence ("high", "medium", "low")
        cost_indicator: Relative cost ("low", "medium", "high")
    """

    resource: str
    action: str
    magnitude: int
    rationale: str
    expected_impact: dict[str, float]
    confidence: str
    cost_indicator: str


@dataclass
class MetricsSummary:
    """Standardized metrics container for agent consumption.

    This is the primary interface between simulation output and agents.
    Agents should ONLY depend on this contract, never on internal
    ResultsCollector implementation details.

    The factory method `from_run_results()` handles conversion from
    raw simulation output to this standardized format.

    Attributes:
        scenario_name: Human-readable scenario identifier
        run_timestamp: ISO timestamp of when simulation was run
        n_replications: Number of replications in this run
        arrivals: Total patient arrivals
        arrivals_by_priority: Dict mapping priority (P1-P4) to count
        arrivals_by_mode: Dict mapping mode (ambulance, etc.) to count
        mean_triage_wait: Mean triage waiting time (minutes)
        mean_treatment_wait: Mean treatment waiting time (minutes)
        p95_treatment_wait: 95th percentile treatment wait (minutes)
        mean_system_time: Mean total time in system (minutes)
        p95_system_time: 95th percentile system time (minutes)
        p_delay: Proportion of patients who waited for treatment
        util_triage: Triage utilization (0-1 scale)
        util_ed_bays: ED bay utilization (0-1 scale)
        util_itu: ITU utilization (0-1 scale)
        util_ward: Ward utilization (0-1 scale)
        util_theatre: Theatre utilization (0-1 scale)
        itu_admissions: Count of ITU admissions
        mean_itu_wait: Mean wait for ITU bed (minutes)
        ward_admissions: Count of ward admissions
        mean_ward_wait: Mean wait for ward bed (minutes)
        theatre_admissions: Count of theatre admissions
        mean_theatre_wait: Mean wait for theatre (minutes)
        mean_boarding_time: Mean time boarding in ED (minutes)
        p_boarding: Proportion of patients who boarded
        mean_handover_delay: Mean ambulance handover delay (minutes)
        max_handover_delay: Maximum handover delay (minutes)
        aeromed_total: Total aeromedical evacuations
        aeromed_slots_missed: Count of missed aeromed slots
        mean_aeromed_slot_wait: Mean wait for aeromed slot (minutes)
        ci_bounds: Optional confidence intervals for metrics
        raw_metrics: Full raw metrics dict for advanced agents
    """

    # Core identifiers
    scenario_name: str
    run_timestamp: str
    n_replications: int

    # Demand metrics
    arrivals: float
    arrivals_by_priority: dict[str, float]
    arrivals_by_mode: dict[str, float]

    # Wait time metrics (minutes)
    mean_triage_wait: float
    mean_treatment_wait: float
    p95_treatment_wait: float
    mean_system_time: float
    p95_system_time: float
    p_delay: float

    # Utilization metrics (0-1 scale)
    util_triage: float
    util_ed_bays: float
    util_itu: float
    util_ward: float
    util_theatre: float

    # Downstream metrics
    itu_admissions: float
    mean_itu_wait: float
    ward_admissions: float
    mean_ward_wait: float
    theatre_admissions: float
    mean_theatre_wait: float

    # Boarding/blocking metrics
    mean_boarding_time: float
    p_boarding: float

    # Handover metrics
    mean_handover_delay: float
    max_handover_delay: float

    # Aeromedical metrics (optional)
    aeromed_total: float = 0.0
    aeromed_slots_missed: float = 0.0
    mean_aeromed_slot_wait: float = 0.0

    # Confidence intervals (optional, for display)
    ci_bounds: dict[str, tuple[float, float]] = field(default_factory=dict)

    # Raw data access (for advanced agents)
    raw_metrics: dict = field(default_factory=dict)

    @classmethod
    def from_run_results(
        cls,
        results: dict,
        scenario_name: str = "Unnamed",
        compute_confidence_intervals: bool = True,
        confidence_level: float = 0.95,
    ) -> "MetricsSummary":
        """Factory method to create MetricsSummary from simulation output.

        Handles conversion from raw simulation results dict (which contains
        lists of values from multiple replications) to aggregated metrics.

        Args:
            results: Dict with metric names as keys and lists of values
            scenario_name: Human-readable name for this scenario
            compute_confidence_intervals: Whether to compute CIs (default True)
            confidence_level: Confidence level for CI calculation (default 0.95)

        Returns:
            MetricsSummary instance with aggregated metrics
        """

        def mean_of(key: str, default: float = 0.0) -> float:
            """Extract mean from list of replication values."""
            values = results.get(key, [default])
            if not values:
                return default
            return sum(values) / len(values)

        # Compute confidence intervals for key metrics
        ci_bounds: dict[str, tuple[float, float]] = {}
        if compute_confidence_intervals:
            from faer.experiment.analysis import compute_ci

            # Metrics that benefit from uncertainty quantification
            ci_metrics = [
                "p_delay",
                "mean_treatment_wait",
                "p95_treatment_wait",
                "mean_system_time",
                "p95_system_time",
                "util_triage",
                "util_ed_bays",
                "util_itu",
                "util_ward",
                "util_theatre",
                "mean_boarding_time",
                "mean_handover_delay",
                "mean_triage_wait",
            ]
            for metric_key in ci_metrics:
                values = results.get(metric_key, [])
                if isinstance(values, list) and len(values) >= 2:
                    ci = compute_ci(values, confidence_level)
                    ci_bounds[metric_key] = (ci["ci_lower"], ci["ci_upper"])

        return cls(
            scenario_name=scenario_name,
            run_timestamp=datetime.now().isoformat(),
            n_replications=len(results.get("arrivals", [1])),
            # Demand
            arrivals=mean_of("arrivals"),
            arrivals_by_priority={
                "P1": mean_of("arrivals_P1"),
                "P2": mean_of("arrivals_P2"),
                "P3": mean_of("arrivals_P3"),
                "P4": mean_of("arrivals_P4"),
            },
            arrivals_by_mode={
                "ambulance": mean_of("arrivals_ambulance", 0),
                "helicopter": mean_of("arrivals_helicopter", 0),
                "walk_in": mean_of("arrivals_walkin", 0),
            },
            # Wait times
            mean_triage_wait=mean_of("mean_triage_wait"),
            mean_treatment_wait=mean_of("mean_treatment_wait"),
            p95_treatment_wait=mean_of("p95_treatment_wait"),
            mean_system_time=mean_of("mean_system_time"),
            p95_system_time=mean_of("p95_system_time"),
            p_delay=mean_of("p_delay"),
            # Utilization
            util_triage=mean_of("util_triage"),
            util_ed_bays=mean_of("util_ed_bays"),
            util_itu=mean_of("util_itu", 0),
            util_ward=mean_of("util_ward", 0),
            util_theatre=mean_of("util_theatre", 0),
            # Downstream
            itu_admissions=mean_of("itu_admissions", 0),
            mean_itu_wait=mean_of("mean_itu_wait", 0),
            ward_admissions=mean_of("ward_admissions", 0),
            mean_ward_wait=mean_of("mean_ward_wait", 0),
            theatre_admissions=mean_of("theatre_admissions", 0),
            mean_theatre_wait=mean_of("mean_theatre_wait", 0),
            # Boarding
            mean_boarding_time=mean_of("mean_boarding_time", 0),
            p_boarding=mean_of("p_boarding", 0),
            # Handover
            mean_handover_delay=mean_of("mean_handover_delay", 0),
            max_handover_delay=mean_of("max_handover_delay", 0),
            # Aeromedical
            aeromed_total=mean_of("aeromed_total", 0),
            aeromed_slots_missed=mean_of("aeromed_slots_missed", 0),
            mean_aeromed_slot_wait=mean_of("mean_aeromed_slot_wait", 0),
            # Confidence intervals
            ci_bounds=ci_bounds,
            # Raw
            raw_metrics=results,
        )


@runtime_checkable
class ClinicalAgent(Protocol):
    """Protocol defining the agent interface contract.

    All agents must implement this interface. This enables:
    - Dependency injection for testing
    - Runtime agent swapping (heuristic → LLM)
    - Future microservice decomposition

    Implementing classes must provide:
    - name: Unique identifier string
    - description: Human-readable purpose
    - analyze(): Core method transforming metrics to insights
    - health_check(): Verify agent is operational
    """

    @property
    def name(self) -> str:
        """Unique agent identifier."""
        ...

    @property
    def description(self) -> str:
        """Human-readable agent purpose."""
        ...

    def analyze(self, metrics: MetricsSummary) -> list[ClinicalInsight]:
        """Core analysis method: metrics → insights.

        Args:
            metrics: Standardized simulation output summary

        Returns:
            List of clinical insights (may be empty)

        Raises:
            AgentExecutionError: If analysis fails unrecoverably
        """
        ...

    def health_check(self) -> bool:
        """Verify agent is operational.

        For heuristic agents, always returns True.
        For LLM agents, verifies API key and connectivity.
        """
        ...


@dataclass
class AgentResult:
    """Container for agent execution result with metadata.

    Captures both the insights produced and execution metadata
    for observability and debugging.

    Attributes:
        agent_name: Name of the agent that produced this result
        execution_time_ms: Time taken to execute (milliseconds)
        insights: List of insights produced
        success: Whether execution completed successfully
        error_message: Error details if success is False
    """

    agent_name: str
    execution_time_ms: float
    insights: list[ClinicalInsight]
    success: bool
    error_message: Optional[str] = None


class AgentExecutionError(Exception):
    """Raised when an agent fails to execute.

    This exception should be caught by the orchestrator for
    fail-open behavior. It should include enough context to
    diagnose the failure.
    """

    pass


# ============ SYSTEM EVALUATION DATA MODELS ============


@dataclass
class StructuralAssessment:
    """Structural strengths and weaknesses assessment.

    Provides high-level analysis of system configuration and
    performance characteristics from a systems engineering perspective.

    Attributes:
        strengths: List of system strengths identified
        weaknesses: List of system vulnerabilities or constraints
        bottleneck_chain: Ordered list of resources in bottleneck cascade
        resilience_score: 0-100 score indicating system's ability to handle surge
        headroom_by_resource: Dict of resource -> remaining capacity fraction
    """

    strengths: list[str]
    weaknesses: list[str]
    bottleneck_chain: list[str]
    resilience_score: float
    headroom_by_resource: dict[str, float]


@dataclass
class PeakLoadAnalysis:
    """Peak load and overloading analysis.

    Analyzes arrival patterns and capacity stress from arrival data,
    relevant to pre-hospital/paramedic and health data scientist perspectives.

    Attributes:
        peak_arrival_rate: Maximum arrival rate per hour observed
        mean_arrival_rate: Average arrival rate per hour
        peak_to_mean_ratio: Ratio indicating burstiness of arrivals
        time_above_capacity_pct: Percentage of time system was over threshold
        bolus_pattern_detected: Whether bolus (wave) arrivals were detected
        estimated_surge_headroom: Minutes of surge the system can absorb
        queue_buildup_rate: Rate at which queues grow during peak (patients/hr)
    """

    peak_arrival_rate: float
    mean_arrival_rate: float
    peak_to_mean_ratio: float
    time_above_capacity_pct: float
    bolus_pattern_detected: bool
    estimated_surge_headroom: float
    queue_buildup_rate: float


@dataclass
class ExpertPerspective:
    """Single expert perspective on simulation results.

    Represents analysis from a specific clinical or operational viewpoint,
    providing domain-specific insights that a generalist might miss.

    Attributes:
        expert_role: Role identifier (e.g., "em_consultant", "anaesthetist")
        expert_title: Human-readable title (e.g., "Emergency Consultant")
        focus_area: Primary area of concern for this expert
        assessment: Overall assessment text
        concerns: List of specific concerns from this perspective
        recommendations: List of recommendations from this perspective
        key_metrics: Dict of metrics most relevant to this expert
        severity: Overall severity from this expert's viewpoint
    """

    expert_role: str
    expert_title: str
    focus_area: str
    assessment: str
    concerns: list[str]
    recommendations: list[str]
    key_metrics: dict[str, float]
    severity: Severity


@dataclass
class SystemEvaluation:
    """Comprehensive system evaluation combining multiple analysis types.

    Aggregates structural assessment, peak load analysis, and multi-expert
    perspectives into a unified evaluation suitable for clinical and
    operational decision-making.

    Attributes:
        structural: Structural strengths/weaknesses assessment
        peak_load: Peak load and overloading analysis
        expert_perspectives: List of expert perspective analyses
        overall_system_status: Aggregate status (normal, warning, critical)
        summary_text: Executive summary text
        timestamp: ISO timestamp of evaluation
    """

    structural: StructuralAssessment
    peak_load: PeakLoadAnalysis
    expert_perspectives: list[ExpertPerspective]
    overall_system_status: str
    summary_text: str
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
